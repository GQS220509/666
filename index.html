<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 新年快乐 - Touch Interactive</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; 
            width: 100%;
            height: 100%;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* 禁止浏览器默认缩放行为 */
        }

        #canvas-wrapper {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1100 0%, #000000 90%);
            overflow: hidden;
        }

        #canvas-container { width: 100%; height: 100%; display: block; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        
        #controls {
            position: absolute; top: 20px; right: 20px; z-index: 200;
            display: flex; gap: 15px;
            transition: opacity 0.5;
        }
        .icon-btn {
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(0,0,0,0.5); border: 1px solid rgba(255,215,0,0.5);
            color: #ffd700; font-size: 20px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; backdrop-filter: blur(4px); transition: 0.3;
        }
        .icon-btn:hover { background: rgba(255,215,0,0.2); box-shadow: 0 0 15px rgba(255,215,0,0.3); }

        #ui-layer {
            position: absolute; top: 30px; left: 30px; z-index: 3; pointer-events: none;
            color: #fff; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            transition: opacity 0.5; display: none;
        }
        
        #cake-upload-btn {
            pointer-events: auto;
            margin-top: 15px;
            background: rgba(255, 215, 0, 0.15); 
            border: 1px solid rgba(255, 215, 0, 0.6); 
            color: #ffd700; 
            padding: 8px 20px; 
            cursor: pointer; 
            font-weight: bold;
            font-size: 0.9rem; 
            border-radius: 20px; 
            backdrop-filter: blur(5px);
            transition: 0.3;
            display: inline-block;
        }
        #cake-upload-btn:hover { background: rgba(255, 215, 0, 0.4); color: #fff; }

        .force-hide { opacity: 0 !important; pointer-events: none !important; }

        h1 {
            font-weight: 300; letter-spacing: 4px; font-size: 2.5rem; margin: 0 0 15px 0;
            background: linear-gradient(to bottom, #fff 30%, #ffd700 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255,215,0,0.5));
        }

        .instructions {
            font-size: 1rem; color: #fff; line-height: 1.8; max-width: 320px;
            background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 12px;
            border-left: 3px solid #ffd700; backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .highlight { color: #ffd700; font-weight: bold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); }
        #status-text { margin-bottom: 10px; font-size: 1.1rem; color: #fff; font-weight: bold; letter-spacing: 1px; }
        
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50; background: radial-gradient(circle, rgba(30,15,0,0.98) 0%, #000 100%);
            transition: opacity 1.2s ease-out;
        }

        .start-controls {
            display: flex; flex-direction: column; align-items: center; gap: 20px; margin-top: 30px;
        }

        #start-btn {
            position: relative; display: none; padding: 20px 60px;
            font-family: 'Microsoft YaHei', sans-serif; font-size: 1.8rem; font-weight: 600; letter-spacing: 8px;
            color: #8a6d00; background: linear-gradient(135deg, #ffffff 0%, #fffde7 40%, #ffd700 100%);
            border: 1px solid rgba(255,255,255,0.8); border-radius: 60px; cursor: pointer;
            box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.2), 0 15px 50px rgba(255, 215, 0, 0.5);
            transition: all 0.4s;
        }
        #start-btn:hover { transform: scale(1.05); box-shadow: 0 0 0 6px rgba(255, 215, 0, 0.4), 0 20px 70px rgba(255, 215, 0, 0.9); }

        #upload-btn {
            display: none; pointer-events: auto; background: rgba(255, 215, 0, 0.1); 
            border: 1px solid rgba(255, 215, 0, 0.5); color: #ffd700; padding: 12px 30px; cursor: pointer; font-weight: bold;
            font-size: 1rem; transition: 0.3s; border-radius: 50px; backdrop-filter: blur(5px);
            text-transform: uppercase; letter-spacing: 2px;
        }
        #upload-btn:hover { background: rgba(255, 215, 0, 0.3); color: #fff; box-shadow: 0 0 15px rgba(255,215,0,0.4); }
        #file-input { display: none; }

        #loading-text { color: #ffd700; font-size: 1.2rem; letter-spacing: 3px; animation: pulse 1s infinite alternate; }
        @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; text-shadow: 0 0 20px #ffd700; } }

        @media screen and (max-width: 768px) {
            h1 { font-size: 1.8rem; letter-spacing: 2px; }
            #ui-layer { top: 20px; left: 20px; width: calc(100% - 40px); }
            .instructions { font-size: 0.85rem; padding: 10px; max-width: none; width: 100%; box-sizing: border-box;}
            #start-btn { padding: 15px 40px; font-size: 1.4rem; }
            #controls { top: 15px; right: 15px; }
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
</script>
</head>
<body>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
        
        <audio id="bgm" loop preload="auto">
            <source src="https://raw.githubusercontent.com/GQS220509/666/main/FIND%20YOU%20-%20G.E.M.%20%E9%82%93%E7%B4%AB%E6%A3%8B.mp3" type="audio/mp3">
        </audio>

        <div id="controls" style="display:none;">
            <div class="icon-btn" id="music-btn" onclick="toggleMusic()">♫</div>
            <div class="icon-btn" id="fullscreen-btn" onclick="toggleFullscreen()">⛶</div>
        </div>

        <div id="start-screen">
            <div id="loading-text">资源预加载中 (0%)...</div>
            <div class="start-controls">
                <button id="start-btn" onclick="startExperience()">开启 2026</button>
                <button id="upload-btn" onclick="document.getElementById('file-input').click()">上传照片</button>
            </div>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>

        <div id="ui-layer">
            <h1>2026 Golden Splendor</h1>
            <div id="status-text">系统就绪</div>
            <div class="instructions">
                • <span class="highlight">拖动</span> : 360° 旋转视角<br/>
                • <span class="highlight">滚轮/捏合</span> : 缩放视角<br/>
                • <span class="highlight">点击中心</span> : 聚合/散开蛋糕<br/>
                • <span class="highlight">点击照片</span> : 放大查看
            </div>
            
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

        const CONFIG = {
            goldCount: 800, silverCount: 600, gemCount: 600, emeraldCount: 400, dustCount: 2000,
            snowCount: 3000, 
            introParticleCount: 12000, 
            tiers: [
                { radius: 25, height: 18, yBottom: -27 }, 
                { radius: 18, height: 15, yBottom: -9 },  
                { radius: 10, height: 12, yBottom: 6 }    
            ]
        };

        const STATE = { TREE: 'tree', SCATTER: 'scatter', ZOOM: 'zoom' };
        const APP_MODE = { INTRO: 'intro', CAKE: 'cake' };

        let currentMode = APP_MODE.INTRO;
        let currentState = STATE.TREE;
        
        let scene, camera, renderer, composer;
        let mainGroup = new THREE.Group();
        let introGroup = new THREE.Group();
        let snowSystem, textGroup; 
        let goldMesh, silverMesh, gemMesh, emeraldMesh, dustSystem;
        let photoMeshes = [];
        let zoomTargetIndex = -1;

        let logicData = { gold: [], silver: [], gem: [], emerald: [], dust: [] };
        const dummy = new THREE.Object3D();
        let time = 0;
        
        let introActive = true; 
        
        let fontGlobal;
        let introParticles;
        let introLogic = []; 
        let introTimelineStep = 0; 
        let introTimer = 0;
        let cachedTextTargets = {}; 
        let isWarping = false; 

        // 交互变量（hcc的原创代码 请勿侵权或随意传播 定制联系qq840473750）
        let rotationVelocity = { x: 0, y: 0 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetCameraZ = 140; // 目标相机距离
        
        // 射线检测
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Music & Fullscreen
        const bgm = document.getElementById('bgm');
        
        window.toggleMusic = function() {
            if (bgm.paused) {
                bgm.play().then(() => {
                    document.getElementById('music-btn').style.color = '#00ff00';
                    document.getElementById('music-btn').style.borderColor = '#00ff00';
                }).catch(e => console.log("Audio play failed", e));
            } else {
                bgm.pause();
                document.getElementById('music-btn').style.color = '#ffd700';
                document.getElementById('music-btn').style.borderColor = 'rgba(255, 215, 0, 0.5)';
            }
        };

        let isFullscreenActive = false;

        window.toggleFullscreen = function() {
            const elem = document.documentElement;
            isFullscreenActive = !isFullscreenActive;
            updateUIForFullscreen(isFullscreenActive);

            if (isFullscreenActive) {
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        };

        function updateUIForFullscreen(isFull) {
            const uiLayer = document.getElementById('ui-layer');
            const controls = document.getElementById('controls');

            if (isFull) {
                uiLayer.classList.add('force-hide');
                controls.classList.add('force-hide');
            } else {
                uiLayer.classList.remove('force-hide');
                controls.classList.remove('force-hide');
            }
            setTimeout(onWindowResize, 100);
            setTimeout(onWindowResize, 500);
        }

        document.addEventListener('fullscreenchange', () => {
             const isFs = document.fullscreenElement || document.webkitFullscreenElement;
             if (isFs !== null) {
                 isFullscreenActive = !!isFs;
                 updateUIForFullscreen(isFullscreenActive);
             }
        });

        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;
            
            if (type === 'sparkle') { 
                const grad = ctx.createRadialGradient(cx,cy,0, cx,cy,60);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.15, 'rgba(255,240,150,1)'); 
                grad.addColorStop(0.5, 'rgba(255,160,0,0.4)');  
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,128,128);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.moveTo(cx, 0); ctx.lineTo(cx+4, cy); ctx.lineTo(cx, 128); ctx.lineTo(cx-4, cy);
                ctx.moveTo(0, cy); ctx.lineTo(cx, cy-4); ctx.lineTo(128, cy); ctx.lineTo(cx, cy+4);
                ctx.fill();
            } else if (type === 'snow') { 
                const grad = ctx.createRadialGradient(cx,cy,0, cx,cy,64);
                grad.addColorStop(0, 'rgba(255,250,230,0.9)');
                grad.addColorStop(0.4, 'rgba(255,215,0,0.4)'); 
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,128,128);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050300, 0.002); 

                const dims = updateDimensions();
                camera = new THREE.PerspectiveCamera(50, dims.width / dims.height, 0.1, 1000);
                
                const isPortrait = dims.height > dims.width;
                targetCameraZ = isPortrait ? 200 : 140;
                camera.position.set(0, 0, targetCameraZ);

                renderer = new THREE.WebGLRenderer({ 
                    antialias: window.devicePixelRatio < 2, 
                    powerPreference: "high-performance", 
                    alpha: true 
                });
                renderer.setSize(dims.width, dims.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0; 
                container.appendChild(renderer.domElement);

                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

                scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const mainSpot = new THREE.SpotLight(0xffaa00, 250); 
                mainSpot.position.set(50, 80, 50); mainSpot.penumbra = 0.5; scene.add(mainSpot);
                const fillLight = new THREE.PointLight(0xffd700, 80, 200);
                fillLight.position.set(-50, 20, 50); scene.add(fillLight);

                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(dims.width, dims.height), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.85; 
                bloomPass.strength = 0.8;   
                bloomPass.radius = 0.5;     

                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                createMaterialsAndMeshes();
                createDust();
                createGoldenSnow(); 
                createStarField();
                scene.add(mainGroup);
                
                mainGroup.visible = false; 

                createIntroSystem();
                setupInteraction(); // 设置鼠标/触屏交互（hcc的原创代码 请勿侵权或随意传播 定制联系qq840473750）

                const loader = new FontLoader();
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', async function (font) {
                    fontGlobal = font;
                    await preCalculateTargets(); 
                    document.getElementById('loading-text').style.display = 'none';
                    document.getElementById('start-btn').style.display = 'inline-block';
                    document.getElementById('upload-btn').style.display = 'inline-block';
                    
                    // 添加内置照片
                    addBuiltinPhotos();
                }, undefined, function(err) {
                    console.error("字体加载失败", err);
                    document.getElementById('loading-text').innerText = "资源加载失败，请刷新重试";
                });

                window.addEventListener('resize', onWindowResize);
                animate();
            } catch (e) {
                console.error("Three.js 初始化失败:", e);
                document.getElementById('loading-text').innerText = "初始化错误，请检查浏览器兼容性";
            }
        }

        // 添加内置照片
        function addBuiltinPhotos() {
            const photoUrls = [
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E4%B8%89%E5%8D%81%E5%85%AD%E7%A2%B0%E6%9D%AF.jpg', 
                    text: '这是我们心心念念很久的野果虽然不太好吃但是还是一段很美好的纪念' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%85%AB%E4%B8%AD%E7%AF%9D%E7%81%AB%E8%8A%82.jpg', 
                    text: '我们第一次合照，也是我们第一次在一起过的元旦晚会很开心，和小美有了第一段照片回忆' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%89%8D%E5%BE%80%E5%8E%A6%E9%97%A8.jpg', 
                    text: '这是我们的第一次旅行我们去到了厦门真的很美，心里特别的激动' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%8E%A6%E9%97%A8%E6%B2%99%E5%9D%A1%E5%B0%BE.jpg', 
                    text: '来到厦门的合照，沙坡尾很好玩' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%8E%A6%E9%97%A8%E8%9D%B4%E8%9D%B6.jpg', 
                    text: '小美和蝴蝶的照片也是超级的美' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%A4%A7%E5%A4%B4%E7%85%A7.jpg', 
                    text: '我们的大头照，我"舍命陪君子"但是真的很好看' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%A4%A9%E9%97%A8%E5%B1%B1%E6%89%8B%E6%9C%BA%E5%90%88%E7%85%A7.jpg', 
                    text: '顶峰相见' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E6%9C%80%E6%96%B0%E7%9A%84%E6%AD%A6%E6%B1%89%E4%B9%8B%E6%97%85.jpg', 
                    text: '好喜欢这张照片，最近的一次武汉之旅' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E5%90%88%E7%85%A7.jpg', 
                    text: '为我们的高中生活画上了一段句号' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E6%B2%99%E6%BB%A9%E7%BE%8E%E7%85%A7.jpg', 
                    text: '我手机里面小美最好看的一张照片了' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9D%A5%E6%AD%A6%E6%B1%89%E6%88%91%E7%9A%84%E5%81%B7%E6%8B%8D.jpg', 
                    text: '小美的第一次武汉游被我偷拍下来了' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%8E%A6%E9%97%A8%E5%9C%B0%E9%93%81.jpg', 
                    text: '小美靠着我在厦门地铁拍的照片' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%B0%8F%E7%BE%8E%E6%BC%94%E5%94%B1%E4%BC%9A.jpg', 
                    text: '第一次去听演唱会超级美，至此之后爱上了邓紫棋' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E5%B0%8F%E7%BE%8E%E7%BE%8E%E7%85%A7%E5%8A%A0%E4%B8%80.jpg', 
                    text: '又是一张被我偷偷截图的美照' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E6%8A%8A%E9%85%92%E8%B0%88%E5%BF%83.jpg', 
                    text: '去厦门的夜晚我们把酒言欢喝了之后聊了很多' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E9%AB%98%E4%B8%AD%E5%81%B7%E6%8B%8D.jpg', 
                    text: '高中的时候偷偷拍的小美吃饭，真的好可爱' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E8%B4%AA%E7%9D%A1%E7%9A%84%E5%B0%8F%E7%BE%8E.jpg', 
                    text: '“贪睡”的小美又靠着我的肩膀睡着了（其实是因为我们的特种兵旅行）' 
                },
                { 
                    src: 'https://raw.githubusercontent.com/GQS220509/666/main/photo/%E9%85%92%E5%BA%97%E5%AF%B9%E9%95%9C%E8%87%AA%E6%8B%8D.jpg', 
                    text: '小美衣服没有带够穿她给我买的衣服' 
                },
            ];

            // 加载内置照片
            photoUrls.forEach((photoItem, index) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = photoItem.src;
                img.onload = () => {
                    // 传递文字描述
                    addPhotoMesh(img, photoItem.text);
                };
                img.onerror = () => {
                    // 如果图片加载失败，使用默认的canvas图片
                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 200;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = `hsl(${index * 60}, 70%, 60%)`;
                    ctx.fillRect(0, 0, 200, 200);
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('照片', 100, 100);
                    
                    const imgFallback = new Image();
                    imgFallback.src = canvas.toDataURL();
                    imgFallback.onload = () => {
                        addPhotoMesh(imgFallback, `默认照片 ${index + 1}`);
                    };
                };
            });
        }

        // --- 新增：交互事件处理 ---（hcc的原创代码 请勿侵权或随意传播 定制联系qq840473750）
        function setupInteraction() {
            const container = document.getElementById('canvas-container');

            // 1. 拖拽旋转
            container.addEventListener('mousedown', onPointerDown);
            container.addEventListener('touchstart', onPointerDown, {passive: false});
            
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('touchmove', onPointerMove, {passive: false});
            
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchend', onPointerUp);

            // 2. 滚轮缩放
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                targetCameraZ += e.deltaY * 0.1;
                targetCameraZ = Math.max(50, Math.min(300, targetCameraZ));
            }, {passive: false});

            // 3. 点击交互 (检测是点击还是拖拽)（hcc的原创代码 请勿侵权或随意传播 定制联系qq840473750）
            let clickStartTime = 0;
            container.addEventListener('mousedown', () => clickStartTime = Date.now());
            container.addEventListener('touchstart', () => clickStartTime = Date.now());
            
            container.addEventListener('click', (e) => {
                if (Date.now() - clickStartTime < 200 && !isDragging) {
                    handleTap(e.clientX, e.clientY);
                }
            });
        }

        function onPointerDown(e) {
            isDragging = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            previousMousePosition = { x: clientX, y: clientY };
        }

        function onPointerMove(e) {
            if (!isDragging || currentMode !== APP_MODE.CAKE) return;
            // 阻止默认滚动
            if(e.touches) e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const deltaX = clientX - previousMousePosition.x;
            const deltaY = clientY - previousMousePosition.y;

            rotationVelocity.y += deltaX * 0.005;
            rotationVelocity.x += deltaY * 0.005;

            previousMousePosition = { x: clientX, y: clientY };
        }

        function onPointerUp() {
            isDragging = false;
        }

        function handleTap(x, y) {
            if (currentMode !== APP_MODE.CAKE) return;

            // 射线检测点击了什么
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // 创建所有可点击对象的数组
            const clickableObjects = [];
            photoMeshes.forEach(group => {
                // 添加组内的图片Mesh（通常是第一个子对象）
                if (group.children.length > 0) {
                    clickableObjects.push(group.children[0]);
                }
            });

            // 优先检测照片
            if (currentState === STATE.SCATTER) {
                const intersects = raycaster.intersectObjects(clickableObjects, true);
                if (intersects.length > 0) {
                    // 找到被点击的组
                    let clickedGroup = null;
                    for (let i = 0; i < photoMeshes.length; i++) {
                        if (photoMeshes[i].children.includes(intersects[0].object) || 
                            intersects[0].object.parent === photoMeshes[i]) {
                            clickedGroup = photoMeshes[i];
                            break;
                        }
                    }
                    
                    if (clickedGroup) {
                        // 点击了照片 -> 放大
                        currentState = STATE.ZOOM;
                        zoomTargetIndex = photoMeshes.indexOf(clickedGroup);
                        document.getElementById('status-text').innerHTML = "状态: <span style='color:#ffd700'>查看照片</span>";
                        return;
                    }
                }
            }

            // 如果没点到照片，或者在放大模式下点击空白 -> 切换整体状态（hcc的原创代码 请勿侵权或随意传播 定制联系qq840473750）
            if (currentState === STATE.ZOOM) {
                // 退出放大
                currentState = STATE.SCATTER;
                zoomTargetIndex = -1;
                document.getElementById('status-text').innerHTML = "状态: <span style='color:#00aaff'>星云散开</span>";
            } else if (currentState === STATE.SCATTER) {
                // 散开 -> 聚合
                currentState = STATE.TREE;
                document.getElementById('status-text').innerHTML = "状态: <span style='color:#00ff00'>聚合成蛋糕</span>";
            } else if (currentState === STATE.TREE) {
                // 聚合 -> 散开
                currentState = STATE.SCATTER;
                document.getElementById('status-text').innerHTML = "状态: <span style='color:#00aaff'>星云散开</span>";
            }
        }

        async function preCalculateTargets() {
            const loading = document.getElementById('loading-text');
            const texts = ["5", "4", "3", "2", "1", "2026"];
            
            const isMobile = window.innerWidth < 768;
            const yearSize = isMobile ? 30 : 55; 
            const sizes = [45, 45, 45, 45, 45, yearSize];
            
            for(let i=0; i<texts.length; i++) {
                loading.innerText = `资源预加载中 (${Math.floor((i/texts.length)*100)}%)...`;
                await new Promise(resolve => setTimeout(resolve, 10));
                cachedTextTargets[texts[i]] = generateTextTargets(texts[i], sizes[i], 10);
            }
        }

        function generateTextTargets(text, size, height) {
            const textGeo = new TextGeometry(text, { font: fontGlobal, size: size, height: 2, curveSegments: 3 });
            textGeo.center();
            textGeo.computeBoundingBox();
            const bounds = textGeo.boundingBox;
            const targets = [];
            const raycaster = new THREE.Raycaster();
            const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial());
            textMesh.updateMatrixWorld();

            const step = 0.8; 
            for(let x = bounds.min.x; x < bounds.max.x; x+=step) {
                for(let y = bounds.min.y; y < bounds.max.y; y+=step) {
                    raycaster.set(new THREE.Vector3(x, y, 50), new THREE.Vector3(0, 0, -1));
                    const intersects = raycaster.intersectObject(textMesh);
                    if(intersects.length > 0) {
                        targets.push(new THREE.Vector3(x, y, (Math.random()-0.5)*height));
                        if(Math.random() > 0.5) targets.push(new THREE.Vector3(x, y, (Math.random()-0.5)*height));
                    }
                }
            }
            textGeo.dispose(); 
            const finalTargets = [];
            for(let i=0; i<CONFIG.introParticleCount; i++) {
                if (i < targets.length) finalTargets.push(targets[i]);
                else finalTargets.push(new THREE.Vector3((Math.random()-0.5)*400, (Math.random()-0.5)*400, (Math.random()-0.5)*200));
            }
            return finalTargets.sort(() => Math.random() - 0.5);
        }

        function createIntroSystem() {
            const geo = new THREE.BufferGeometry();
            const positions = []; const colors = []; const sizes = [];
            const flash = []; const velocities = []; 
            const color1 = new THREE.Color(0xffd700); const color2 = new THREE.Color(0xffffff); 

            for(let i=0; i<CONFIG.introParticleCount; i++) {
                positions.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*100);
                velocities.push(0,0,0);
                const c = Math.random() > 0.3 ? color1 : color2;
                colors.push(c.r * 3.0, c.g * 2.5, c.b * 1.5);
                sizes.push(1.0 + Math.random() * 2.5); 
                flash.push(Math.random() * Math.PI);

                introLogic.push({ currentPos: new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]), targetPos: new THREE.Vector3(0,0,0) });
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('flash', new THREE.Float32BufferAttribute(flash, 1));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const mat = new THREE.PointsMaterial({
                size: 1.5, vertexColors: true, map: createTexture('sparkle'),
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0,
                toneMapped: false 
            });
            introParticles = new THREE.Points(geo, mat);
            introGroup.add(introParticles);
            scene.add(introGroup);
        }

        function applyTargets(key) {
            const targets = cachedTextTargets[key];
            if(!targets) return;
            for(let i=0; i<CONFIG.introParticleCount; i++) {
                introLogic[i].targetPos.copy(targets[i]);
            }
        }

        window.startExperience = function() {
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => { document.getElementById('start-screen').style.display = 'none'; }, 1200);
            
            bgm.volume = 0.5;
            bgm.play().then(() => {
                document.getElementById('music-btn').style.color = '#00ff00';
                document.getElementById('music-btn').style.borderColor = '#00ff00';
            }).catch(() => {});

            introTimelineStep = 1; applyTargets("5"); introTimer = Date.now();
        };

        function updateIntro() {
            if(currentMode !== APP_MODE.INTRO || introTimelineStep === 0 || !introActive) return;
            const now = Date.now();
            const elapsed = now - introTimer;

            if(introTimelineStep === 1 && elapsed > 1000) { introTimelineStep = 2; applyTargets("4"); introTimer = now; }
            else if(introTimelineStep === 2 && elapsed > 1000) { introTimelineStep = 3; applyTargets("3"); introTimer = now; }
            else if(introTimelineStep === 3 && elapsed > 1000) { introTimelineStep = 4; applyTargets("2"); introTimer = now; }
            else if(introTimelineStep === 4 && elapsed > 1000) { introTimelineStep = 5; applyTargets("1"); introTimer = now; }
            else if(introTimelineStep === 5 && elapsed > 1000) { 
                introTimelineStep = 6; applyTargets("2026"); introTimer = now; 
                new TWEEN.Tween(camera.position).to({z: 160}, 2000).easing(TWEEN.Easing.Cubic.Out).start();
            }
            else if(introTimelineStep === 6 && elapsed > 2500) { introTimelineStep = 7; triggerWarpEffect(); }

            const positions = introParticles.geometry.attributes.position.array;
            const sizes = introParticles.geometry.attributes.size.array;
            const flash = introParticles.geometry.attributes.flash.array;
            const vels = introParticles.geometry.attributes.velocity.array;

            for(let i=0; i<CONFIG.introParticleCount; i++) {
                const p = introLogic[i];
                if (isWarping) {
                    p.currentPos.x += vels[i*3]; p.currentPos.y += vels[i*3+1]; p.currentPos.z += vels[i*3+2];
                    vels[i*3+2] *= 1.05; vels[i*3] *= 1.01; vels[i*3+1] *= 1.01;
                } else {
                    const lerpFactor = (introTimelineStep === 6) ? 0.05 : 0.1; 
                    p.currentPos.x += (p.targetPos.x - p.currentPos.x) * lerpFactor;
                    p.currentPos.y += (p.targetPos.y - p.currentPos.y) * lerpFactor;
                    p.currentPos.z += (p.targetPos.z - p.currentPos.z) * lerpFactor;
                    if(introTimelineStep === 6) { p.currentPos.x += (Math.random()-0.5)*0.2; p.currentPos.y += (Math.random()-0.5)*0.2; }
                }
                positions[i*3] = p.currentPos.x; positions[i*3+1] = p.currentPos.y; positions[i*3+2] = p.currentPos.z;
                sizes[i] = (1.5 + Math.sin(time * 8 + flash[i]) * 0.8) * (introTimelineStep===6 ? 1.8 : 1);
            }
            introParticles.geometry.attributes.position.needsUpdate = true;
            introParticles.geometry.attributes.size.needsUpdate = true;
        }

        function triggerWarpEffect() {
            isWarping = true;
            const vels = introParticles.geometry.attributes.velocity.array;
            for(let i=0; i<CONFIG.introParticleCount; i++) {
                vels[i*3] = (Math.random()-0.5) * 1.5; vels[i*3+1] = (Math.random()-0.5) * 1.5; vels[i*3+2] = 0.5 + Math.random() * 2.0; 
            }
            
            new TWEEN.Tween(camera.position).to({z: 100}, 2000).easing(TWEEN.Easing.Quadratic.In).start();
            
            setTimeout(() => {
                mainGroup.visible = true;
                mainGroup.scale.set(0.001, 0.001, 0.001); 
                
                new TWEEN.Tween(mainGroup.scale)
                    .to({x:1, y:1, z:1}, 3500) 
                    .easing(TWEEN.Easing.Cubic.Out) 
                    .start();
                    
                new TWEEN.Tween(mainGroup.rotation)
                    .to({y:0}, 3500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }, 500);

            setTimeout(finishIntro, 1000);
        }

        function finishIntro() {
            new TWEEN.Tween(introParticles.material)
                .to({opacity: 0}, 1000)
                .onComplete(() => { 
                    introActive = false; 
                    scene.remove(introGroup); 
                })
                .start();

            const dims = updateDimensions();
            const finalZ = (dims.height > dims.width) ? 200 : 140;
            targetCameraZ = finalZ;

            new TWEEN.Tween(camera.position).to({z: finalZ}, 2500).easing(TWEEN.Easing.Cubic.Out).start();

            currentMode = APP_MODE.CAKE;
            mainGroup.rotation.y = Math.PI * 1; 

            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('controls').style.display = 'flex'; 
            createHeaderText(); 
        }

        function createGoldenSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = []; const speeds = []; const sizes = [];
            for(let i=0; i<CONFIG.snowCount; i++) {
                pos.push((Math.random()-0.5)*350, (Math.random()-0.5)*350, (Math.random()-0.5)*250);
                speeds.push(0.02 + Math.random()*0.08); 
                sizes.push(2.0 + Math.random() * 4.0); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            const mat = new THREE.PointsMaterial({
                color: 0xffeebb, size: 1.0, map: createTexture('snow'),
                transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false
            });
            snowSystem = new THREE.Points(geo, mat);
            snowSystem.userData = { speeds: speeds };
            scene.add(snowSystem);
        }

        function updateSnow() {
            if(!snowSystem) return;
            const positions = snowSystem.geometry.attributes.position.array;
            const speeds = snowSystem.userData.speeds;
            for(let i=0; i<CONFIG.snowCount; i++) {
                positions[i*3+1] -= speeds[i]; 
                positions[i*3] += Math.sin(time * 0.5 + i)*0.05;
                if(positions[i*3+1] < -120) {
                    positions[i*3+1] = 120; positions[i*3] = (Math.random()-0.5)*350; positions[i*3+2] = (Math.random()-0.5)*250;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y = time * 0.01;
        }

        function createHeaderText() {
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 2048; textCanvas.height = 512;
            const ctx = textCanvas.getContext('2d');
            ctx.clearRect(0, 0, 2048, 512);
            ctx.font = '900 200px "Microsoft YaHei", sans-serif'; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            ctx.strokeStyle = 'rgba(255, 180, 0, 0.9)'; ctx.lineWidth = 6;
            ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 40; 
            ctx.strokeText('2026 新年快乐', 1024, 256);

            const gradient = ctx.createLinearGradient(0, 100, 0, 400);
            gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.3, '#ffd700');
            gradient.addColorStop(0.7, '#ff8c00'); gradient.addColorStop(1, '#8b4500');
            ctx.fillStyle = gradient; ctx.shadowBlur = 0; 
            ctx.fillText('2026 新年快乐', 1024, 256);
            
            const textTex = new THREE.CanvasTexture(textCanvas);
            textTex.colorSpace = THREE.SRGBColorSpace;
            const textMat = new THREE.MeshBasicMaterial({ 
                map: textTex, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
            });
            const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(90, 22.5), textMat);
            const topTier = CONFIG.tiers[CONFIG.tiers.length-1];
            const textY = topTier.yBottom + topTier.height + 20; 
            textPlane.position.set(0, textY, 0);
            textGroup = textPlane;
            mainGroup.add(textGroup);
            new TWEEN.Tween(textGroup.position).to({y: textY + 4}, 2500).yoyo(true).repeat(Infinity).easing(TWEEN.Easing.Sinusoidal.InOut).start();
        }

        function updateDimensions() {
            const width = window.innerWidth; const height = window.innerHeight;
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = width + 'px'; wrapper.style.height = height + 'px';
            return { width, height };
        }

        function createStarGeometry() {
            const shape = new THREE.Shape();
            const outerRadius = 3.5; const innerRadius = 1.6; const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius; const y = Math.sin(angle) * radius;
                if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
            }
            shape.closePath();
            return new THREE.ExtrudeGeometry(shape, { steps: 1, depth: 0.8, bevelEnabled: true, bevelThickness: 0.3, bevelSize: 0.3, bevelSegments: 3 });
        }

        function createMaterialsAndMeshes() {
            const goldMat = new THREE.MeshPhysicalMaterial({ color: 0xffcc00, metalness: 1.0, roughness: 0.1, clearcoat: 1.0, emissive: 0xffaa00, emissiveIntensity: 0.8 });
            const silverMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.3, roughness: 0.1, transmission: 0.2, emissive: 0x444444, emissiveIntensity: 0.2 }); 
            const gemMat = new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.1, roughness: 0.0, transmission: 0.8, thickness: 2.0, emissive: 0xaa0022, emissiveIntensity: 0.8 }); 
            const emeraldMat = new THREE.MeshPhysicalMaterial({ color: 0x00ccff, metalness: 0.2, roughness: 0.1, transmission: 0.5, thickness: 1.5, emissive: 0x004488, emissiveIntensity: 0.8 }); 

            goldMesh = createInstancedMesh(new THREE.SphereGeometry(0.7, 16, 16), goldMat, CONFIG.goldCount, logicData.gold);
            silverMesh = createInstancedMesh(new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16), silverMat, CONFIG.silverCount, logicData.silver); 
            gemMesh = createInstancedMesh(new THREE.SphereGeometry(0.8, 16, 16), gemMat, CONFIG.gemCount, logicData.gem); 
            emeraldMesh = createInstancedMesh(new THREE.ConeGeometry(0.5, 1.2, 8), emeraldMat, CONFIG.emeraldCount, logicData.emerald);

            const starGeo = createStarGeometry(); starGeo.center();
            const star = new THREE.Mesh(starGeo, new THREE.MeshPhysicalMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.0, emissive: 0xffaa00, emissiveIntensity: 2.5 }));
            const topTier = CONFIG.tiers[CONFIG.tiers.length-1];
            const topY = topTier.yBottom + topTier.height + 4;
            star.userData = { treePos: new THREE.Vector3(0, topY, 0), scatterPos: new THREE.Vector3(0, 60, 0) };
            star.position.copy(star.userData.treePos);
            star.add(new THREE.PointLight(0xffaa00, 80, 50)); 
            mainGroup.add(star);
            logicData.star = star;
        }

        function createInstancedMesh(geo, mat, count, dataArray) {
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            mainGroup.add(mesh);
            for (let i = 0; i < count; i++) {
                const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
                const tier = CONFIG.tiers[tierIndex];
                const h = Math.random() * tier.height;
                const r = Math.sqrt(Math.random()) * tier.radius; 
                let finalR = r; if (Math.random() > 0.3) finalR = tier.radius * (0.9 + Math.random() * 0.15); 
                const theta = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(finalR * Math.cos(theta), tier.yBottom + h, finalR * Math.sin(theta));
                dataArray.push({
                    treePos: treePos, scatterPos: randomSpherePoint(40 + Math.random()*40), 
                    currentPos: treePos.clone(), scale: 0.6 + Math.random() * 0.8,
                    rotSpeed: new THREE.Euler(Math.random()*0.03, Math.random()*0.03, Math.random()*0.03),
                    rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0), tierIndex: tierIndex 
                });
            }
            return mesh;
        }

        function randomSpherePoint(r) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }

        function createDust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<CONFIG.dustCount; i++) {
                const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
                const tier = CONFIG.tiers[tierIndex];
                const r = tier.radius * (1.0 + Math.random() * 0.2); 
                const theta = Math.random() * Math.PI * 2;
                const x = r * Math.cos(theta), y = tier.yBottom + Math.random() * tier.height, z = r * Math.sin(theta);
                pos.push(x, y, z);
                logicData.dust.push({ treePos: new THREE.Vector3(x, y, z), scatterPos: randomSpherePoint(60), currentPos: new THREE.Vector3(x, y, z), tierIndex: tierIndex });
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            dustSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffccaa, size: 0.8, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false }));
            mainGroup.add(dustSystem);
        }
        
        function createStarField() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color: 0xffddaa, size: 1.5, transparent: true, opacity: 0.4})));
        }

// 创建带有文字的图片Mesh - 只保留文字，无边框
function addPhotoMesh(img, text = '') {
    const tex = new THREE.Texture(img);
    tex.needsUpdate = true; 
    tex.colorSpace = THREE.SRGBColorSpace;
    
    // 计算图片的宽高比例
    let w = 4, h = 4;
    if(img.width > img.height) {
        h = 4 * (img.height/img.width);
    } else {
        w = 4 * (img.width/img.height);
    }
    
    // 创建一个组来包含图片和文字
    const photoGroup = new THREE.Group();
    
    // 创建图片Mesh
    const mat = new THREE.MeshStandardMaterial({ 
        map: tex, 
        side: THREE.DoubleSide, 
        color: new THREE.Color(0.8, 0.8, 0.8),
        roughness: 0.4,
        metalness: 0.1,
        emissive: 0x222222, 
        emissiveIntensity: 0.5
    });

    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
    
    // 创建金色边框 - 只保留图片框
    const frameGeo = new THREE.BoxGeometry(w+0.2, h+0.2, 0.1);
    const frameMat = new THREE.MeshPhysicalMaterial({
        color: 0xffd700,
        roughness: 0.2,
        metalness: 0.8,
        emissive: 0xffaa00, 
        emissiveIntensity: 0.2
    });
    const frame = new THREE.Mesh(frameGeo, frameMat);
    frame.position.z = -0.06;
    mesh.add(frame);
    
    // 将图片Mesh添加到组中
    photoGroup.add(mesh);
    
    // 如果有文字描述，创建纯文字Mesh（无边框）
    if (text && fontGlobal) {
        // 创建文字纹理 - 纯透明背景，只有文字
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // 先计算文字需要的宽度
        ctx.font = 'bold 22px "Microsoft YaHei", sans-serif';
        const testText = text.length > 30 ? text.substring(0, 30) + "..." : text;
        const textMetrics = ctx.measureText(testText);
        const textWidthPixels = Math.ceil(textMetrics.width) + 40; // 左右各留20px边距
        
        // 设置canvas大小 - 根据文字宽度动态调整
        canvas.width = Math.min(textWidthPixels, 500); // 最大500px
        canvas.height = 150; // 固定高度
        
        // 清空画布 - 完全透明背景
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 设置文字样式
        ctx.font = 'bold 22px "Microsoft YaHei", sans-serif';
        ctx.fillStyle = '#ffd700';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        // 添加文字发光效果
        ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // 文字换行处理
        const maxWidth = canvas.width - 40; // 左右各20px边距
        const lineHeight = 24;
        let y = 20;
        let line = '';
        const words = text.split('');
        
        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n];
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            
            if (testWidth > maxWidth && n > 0) {
                ctx.fillText(line, 20, y);
                line = words[n];
                y += lineHeight;
                // 如果超出canvas高度，停止
                if (y + lineHeight > canvas.height - 20) {
                    line += "...";
                    break;
                }
            } else {
                line = testLine;
            }
        }
        ctx.fillText(line, 20, y);
        
        // 创建文字纹理
        const textTex = new THREE.CanvasTexture(canvas);
        textTex.colorSpace = THREE.SRGBColorSpace;
        
        // 计算文字平面的精确大小
        const textWidth = canvas.width / 100;
        const textHeight = canvas.height / 100;
        
        // 创建纯文字平面 - 无边框，透明背景
        const textMat = new THREE.MeshBasicMaterial({
            map: textTex,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            alphaTest: 0.05 // 很低的alphaTest确保文字清晰
        });
        
        const textPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(textWidth, textHeight),
            textMat
        );
        
        // 将文字放在图片右侧，中间对齐
        textPlane.position.x = w/2 + textWidth/2 + 0.5;
        textPlane.position.y = 0;
        
        photoGroup.add(textPlane);
        
        // 存储文字引用，方便后续控制
        photoGroup.userData.textMesh = textPlane;
        photoGroup.userData.hasText = true;
    } else {
        photoGroup.userData.hasText = false;
    }
    
    // 存储图片Mesh引用，方便射线检测
    photoGroup.userData.photoMesh = mesh;
    
    // 随机分配位置
    const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
    const tier = CONFIG.tiers[tierIndex];
    const h_pos = Math.random() * tier.height;
    const r = tier.radius * 1.1;
    const theta = Math.random() * Math.PI * 2;
    
    const treePos = new THREE.Vector3(
        r * Math.cos(theta), 
        tier.yBottom + h_pos, 
        r * Math.sin(theta)
    );
    
    photoGroup.userData.treePos = treePos;
    photoGroup.userData.scatterPos = randomSpherePoint(50);
    photoGroup.userData.baseRot = new THREE.Euler(0, Math.random()*Math.PI, 0);
    
    photoGroup.position.copy(treePos);
    
    // 将组添加到场景和数组中
    photoMeshes.push(photoGroup);
    mainGroup.add(photoGroup);
}

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            time += 0.01;

            if (currentMode === APP_MODE.INTRO) {
                if (introActive) updateIntro();
                updateSnow(); 
            } else {
                updateInstancedMesh(goldMesh, logicData.gold);
                updateInstancedMesh(silverMesh, logicData.silver);
                updateInstancedMesh(gemMesh, logicData.gem);
                updateInstancedMesh(emeraldMesh, logicData.emerald);
                updateDust();
                updatePhotos();
                updateSnow(); 

                if (logicData.star) {
                    let target = currentState === STATE.TREE ? logicData.star.userData.treePos : logicData.star.userData.scatterPos;
                    logicData.star.position.lerp(target, 0.1);
                    logicData.star.position.y += Math.sin(time * 2) * 0.03;
                    logicData.star.rotation.y += 0.02; 
                }

                if (textGroup) { 
                    textGroup.lookAt(camera.position); 
                    const targetOpacity = (currentState === STATE.TREE) ? 1.0 : 0.0;
                    textGroup.material.opacity += (targetOpacity - textGroup.material.opacity) * 0.1;
                }

                // 惯性与交互更新
                if (currentMode === APP_MODE.CAKE) {
                    // 应用旋转惯性
                    mainGroup.rotation.y += rotationVelocity.y;
                    mainGroup.rotation.x += rotationVelocity.x;
                    
                    // 阻尼效果
                    rotationVelocity.y *= 0.95;
                    rotationVelocity.x *= 0.95;
                    
                    // 自动回正X轴
                    if (!isDragging) {
                        mainGroup.rotation.x *= 0.95;
                    }

                    // 自动旋转（当用户没有操作时）
                    if (Math.abs(rotationVelocity.y) < 0.001 && currentState === STATE.TREE && !isDragging) {
                        mainGroup.rotation.y += 0.003;
                    }

                    // 相机平滑缩放
                    camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
                }
            }
            composer.render();
        }

        function updateInstancedMesh(mesh, dataArray) {
            const isMobile = window.innerWidth < 768;
            const lerpFactor = isMobile ? 0.25 : 0.1;

            for (let i = 0; i < dataArray.length; i++) {
                const item = dataArray[i];
                let target = currentState === STATE.TREE ? item.treePos : item.scatterPos;
                if(currentState === STATE.ZOOM) target = item.scatterPos;
                if (currentState === STATE.SCATTER) item.currentPos.y += Math.sin(time + i)*0.005;

                item.currentPos.lerp(target, lerpFactor);
                
                item.rotation.x += item.rotSpeed.x; item.rotation.y += item.rotSpeed.y;
                let s = item.scale;
                if(currentState === STATE.ZOOM) s = item.scale * 0.6; 

                dummy.position.copy(item.currentPos);
                dummy.rotation.copy(item.rotation);
                dummy.scale.setScalar(s);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        function updateDust() {
            const isMobile = window.innerWidth < 768;
            const lerpFactor = isMobile ? 0.25 : 0.1;
            const positions = dustSystem.geometry.attributes.position.array;
            
            for(let i=0; i<logicData.dust.length; i++) {
                const item = logicData.dust[i];
                let target = currentState === STATE.TREE ? item.treePos : item.scatterPos;
                if(currentState !== STATE.TREE) {
                    item.currentPos.lerp(target, lerpFactor);
                } else {
                    item.currentPos.y += 0.05;
                    const tier = CONFIG.tiers[item.tierIndex];
                    if(item.currentPos.y > tier.yBottom + tier.height) item.currentPos.y = tier.yBottom;
                    if (Math.sqrt(item.currentPos.x**2 + item.currentPos.z**2) > tier.radius * 1.3) {
                        item.currentPos.x *= 0.98; item.currentPos.z *= 0.98;
                    }
                }
                positions[i*3] = item.currentPos.x; positions[i*3+1] = item.currentPos.y; positions[i*3+2] = item.currentPos.z;
            }
            dustSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updatePhotos() {
            const isMobile = window.innerWidth < 768;
            const lerpFactor = isMobile ? 0.25 : 0.1;

            photoMeshes.forEach((group, idx) => {
                let targetPos, targetScale = 2.0; 
                
                if (currentState === STATE.TREE) {
                    targetPos = group.userData.treePos;
                    targetScale = 0; 
                    
                    // 隐藏文字
                    if (group.userData.textMesh) {
                        group.userData.textMesh.visible = false;
                    }
                } else if (currentState === STATE.SCATTER) {
                    targetPos = group.userData.scatterPos;
                    targetScale = 4.0;
                    group.position.y += Math.sin(time+idx)*0.01;
                    
                    // 确保整个组朝向相机
                    group.lookAt(camera.position);
                    
                    // 非放大状态时隐藏文字，避免遮挡
                    if (group.userData.textMesh) {
                        group.userData.textMesh.visible = false;
                    }
                } else if (currentState === STATE.ZOOM) {
                    if (idx === zoomTargetIndex) {
                        const offset = new THREE.Vector3(0, 0, -20); 
                        offset.applyMatrix4(camera.matrixWorld);
                        targetPos = mainGroup.worldToLocal(offset);
                        targetScale = 2.0; 
                        
                        // 放大时正面朝向相机
                        group.lookAt(camera.position);
                        
                        // 控制文字显示：放大时也显示文字
                        if (group.userData.textMesh) {
                            group.userData.textMesh.visible = true;
                            // 确保文字也正对相机
                            group.userData.textMesh.lookAt(camera.position);
                        }
                    } else {
                        targetPos = group.userData.scatterPos;
                        targetScale = 3.0;
                        group.lookAt(camera.position);
                        
                        // 非放大状态时隐藏文字，避免遮挡
                        if (group.userData.textMesh) {
                            group.userData.textMesh.visible = false;
                        }
                    }
                }

                if (currentState === STATE.TREE) {
                    group.rotation.y += 0.01;
                }

                group.position.lerp(targetPos, lerpFactor);
                group.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpFactor);
            });
        }

        function onWindowResize() {
            const dims = updateDimensions();
            if(dims.width === 0 || dims.height === 0) return;
            
            camera.aspect = dims.width / dims.height;
            camera.updateProjectionMatrix();
            
            const isPortrait = dims.height > dims.width;
            // 只有当不是用户手动缩放时才重置距离
            if(currentMode === APP_MODE.CAKE && !isDragging) {
               targetCameraZ = isPortrait ? 200 : 140;
            }

            renderer.setSize(dims.width, dims.height);
            composer.setSize(dims.width, dims.height);
            composer.passes[1].resolution.set(dims.width, dims.height);
        }

        document.getElementById('file-input').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files.length) return;
            for(let i=0; i<files.length; i++) {
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => { addPhotoMesh(img, `上传的照片 ${i+1}`); }
                }
                reader.readAsDataURL(files[i]);
            }
            alert(`已添加 ${files.length} 张照片`);
        });

        initThree();
    </script>
</body>
</html>

